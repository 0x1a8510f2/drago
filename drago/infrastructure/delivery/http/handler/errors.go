package handler

import (
	"errors"
	"fmt"

	"github.com/seashell/drago/drago/application"
)

const (
	errMethodNotAllowed = "method not allowed"
	errInvalidMethod    = "invalid method"
	errNotImplemented   = "not implemented"
	errUnauthorized     = "unauthorized"
	errBadRequest       = "bad request"
	errInternal         = "internal error"
	errNotFound         = "not found"
)

var (
	// ErrMethodNotAllowed :
	ErrMethodNotAllowed = errors.New(errMethodNotAllowed)

	// ErrInvalidMethod :
	ErrInvalidMethod = errors.New(errInvalidMethod)

	// ErrInternal :
	ErrInternal = errors.New(errInternal)

	// ErrNotImplemented :
	ErrNotImplemented = errors.New(errNotImplemented)

	// ErrUnauthorized :
	ErrUnauthorized = errors.New(errUnauthorized)

	// ErrBadRequest :
	ErrBadRequest = errors.New(errBadRequest)

	// ErrNotFound :
	ErrNotFound = errors.New(errNotFound)
)

// HTTPError represents an error generated by an HTTP handler.
// Besides implementing the standard error interface, it also
// implements a method for obtaining the HTTP status code
// associated with the error.
type HTTPError struct {
	// Code is an HTTP status code associated with the error.
	code int
	// Message is a human-readable message that describes the error.
	message string
}

// NewError :
func NewError(code int, base error, extra ...interface{}) *HTTPError {
	msg := base.Error()
	for _, v := range extra {
		msg = fmt.Sprintf("%s : %v", msg, v)
	}
	return &HTTPError{code, msg}
}

// Error returns a string representation for the Error type.
func (e *HTTPError) Error() string {
	return fmt.Sprintf("%s", e.message)
}

// Code returns the HTTP status code associated with the error.
func (e *HTTPError) Code() int {
	return e.code
}

func toHTTPError(err error) *HTTPError {
	switch err {
	case application.ErrTokenNotFound:
		return NewError(404, err)
	default:
		return NewError(500, ErrInternal)
	}
}
